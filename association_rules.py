# -*- coding: utf-8 -*-
"""Association Rules.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pevJqHPGZyncoRqEPQzK6O0TdER7XGSB
"""

#Import the libraries
import math
import pandas_datareader as web
import numpy as np
import pandas as pd

#Load the data
from google.colab import files
uploaded = files.upload()

df = pd.read_csv("Lab2_store_data.csv", header = None)

df

df.shape

#Total number of Transactions
no_of_trans = df.shape[0]

#Converting the pandas dataframe into a list of lists
record = []
for i in range(0,7501):
  record.append([str(df.values[i,j]) for j in range(0, 20)])

record

#Removing NaN values from the record and saving it to new_record
new_record = []
for p in record:
  z = [x for x in p if x != 'nan']
  new_record.append(z)
print(new_record)

#Converting list of list to list of sets of Transaction
k = []
for i in new_record:
  z = set(i)
  k.append(z)

k

#Storing unique items in a list
unique_list = []
for trans in new_record:
    for item in trans:
        # check if exists in unique_list or not
        if item not in unique_list:
          unique_list.append(item)

unique_list

#Converting list of unique string item to list of set item
unique_set = []

for i in unique_list:
  temp = set()
  temp.add(i)
  unique_set.append(temp)

unique_set

#Function to calculate support
glb2 = []
glb2_supp = []

glb_support_store = []

def Process_Support(unique_set, min_supp, flag = True):
  #print("Number of unique sets with element :: ",len(unique_set[0]),"are", len(unique_set))
  while(flag):
   
    #Frequency of item set
    count = []

    for item_chq in unique_set:
      item_count = 0
      for trans in k:
        if(item_chq.issubset(trans)):
            item_count+= 1
      count.append(item_count)

    #Calculating support of item set
    support = []

    for z in count:
      supp_val = (z / no_of_trans)
      support.append(supp_val)

    #*************************************************
    supp_store = []
    for i in range(0, len(unique_set)):
      glb2.append(unique_set[i])
      glb2_supp.append(support[i])
    #*************************************************

    #Checking minimum support value    
    new_list = []
    len_min_supp = 0
    for i in range(0, len(support)):
      if(support[i] > min_supp):
        new_list.append(unique_set[i]) 
        len_min_supp+= 1 
        print("Rule: ", unique_set[i] ," -> ", "Support: ", support[i])
        print("--------------------------------------------------------------------------")
         
        if unique_set[i] not in glb_support_store:
          glb_support_store.append(unique_set[i])

    print("LENGTH = ", len_min_supp)
    print("*************************************************************************")

    #Creating new item set Dataset for association using union operator
    new_list2 = []
    for i in range(0,len(new_list)-1):
      for j in range(i+1,len(new_list)):
        temp = new_list[i]|new_list[j]
        if temp not in new_list2:
          new_list2.append(temp)

    if(len_min_supp==0):
      Process_Support(new_list2, min_supp, False)
    else:
      Process_Support(new_list2, min_supp)
    return
  return

Process_Support(unique_set, min_supp = 0.04)

glb_support_store

#print(len(glb2))
#print(len(glb2_supp))

#For printing all items set which are ever stored in Candidate Item Table
#for i in range(0, len(glb2)):
#  print(glb2[i],"---->","support : ",glb2_supp[i])

association_store = []

for asso in glb_support_store:
  if(len(asso)>1):
    association_store.append(asso)

#assoction_store stores unique sets for confidence check
association_store

#Confidence to be calculated further

import itertools
from itertools import combinations, chain

def findsubsets(s, n):
    return list(map(set, itertools.combinations(s, n)))

def common_data(set1, set2):
    result = False
  
    # traverse in the 1st list
    for x in set1:
  
        # traverse in the 2nd list
        for y in set2:
    
            # if one common
            if x == y:
                result = True
                return result 
                  
    return result

def find_support(set1, set2, set3):
  
  for i in range(0, len(glb2)):
    if(set1==glb2[i]):
      x = glb2_supp[i]
      break

  for j in range(0, len(glb2)):
    if(set2==glb2[j]):
      y = glb2_supp[j]
      break

  for k in range(0, len(glb2)):
    if(set3==glb2[k]):
      z = glb2_supp[k]
      break
  return (x, y, z)

#assoction_store stores unique sets for confidence check
association_store

#For calulating Associations Rules whose confidence is less then min_conf

def process_confidence(list_ass_rule, min_conf):
  l1 = []

  for asso_set in list_ass_rule:
    ln = len(asso_set)

    all_subset = []
    for i in range(1, ln):
      p = findsubsets(asso_set, i)
      #print(p)
      for item in p:
        all_subset.append(item)

    
    for j in range(0, len(all_subset)-1):
      for k in range(j+1, len(all_subset)):
        if( (all_subset[j].issubset(all_subset[k])==False ) and (len(all_subset[j])+len(all_subset[k])==ln) and ( common_data(all_subset[j], all_subset[k])==False) ):
          sup1, sup2, sup3 = find_support( asso_set, all_subset[j], all_subset[k] )
          
          conf1 = sup1 / sup2
          if( conf1>= min_conf):
            print(all_subset[j],"--->",all_subset[k]," ::  confidence = ",conf1)
      
          conf2 = sup1 / sup3
          if( conf2>=min_conf):
            print(all_subset[k],"--->",all_subset[j]," ::  confidence = ",conf2)

    #print("-----------------------------------------------------------------------------------------------------------")

process_confidence(association_store, min_conf = 0.3)





#----------------------------------------CROSS CHECK OUR RESULT USING APRORI LIBRARY-----------------------------------------------
!pip install apyori





from apyori import apriori

ass_rules = apriori(new_record,  min_support = .04, confidence = 0.2)
ass_rslts = list(ass_rules)

print(len(ass_rslts))

ass_rslts

for item in ass_rslts:
    # first index of the inner list
    # Contains base item and add item
   # pair = item[0]
    #items = [x for x in pair]
    print("Rule: ", item[0] ," -> ", "Support: ",item[1], "Confidence: ",item[2])
    print("--------------------------------------------------------------------------")